# Spring boot fundamental

`@SpringBootApplication` annotation is a combination of
multiple annotations, such as the following:

- `@EnableAutoConfiguration`: enables automatic configuration based on dependencies. e.g. `spring-boot-starter-web`
  assumes that you're developing a web application and configure it accordingly.
- `@ComponentScan`: scan to find all components
- `@Configure`: defines a class as a source of bean definitions

## Json serialization infinite loop which happens on account of one-to-many relationship between the car and owner tables.

One solution: `@JsonIgnoreProperties({"hibernateLazyInitializer", "handler"})` + `@JsonIgnore`

GET `/api/v1/cars`

```diff
// ignore fields generated by Hibernate:
+ @JsonIgnoreProperties({"hibernateLazyInitializer", "handler"})
public class Owner {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long ownerId;

    // ...

    // 1 owner can have many cars
    @OneToMany(cascade = CascadeType.ALL, mappedBy = "owner")
    // mappedBy value is the field in Car class (private Owner `owner`)
+    @JsonIgnore
    private List<Car> cars;
}
```

This means when cars get owners, at the owners place, stop fetching cars. So the result is like

```json5
{
  "car": {
    "carId": 1,
    "owner": {
      "ownerId": 2
      // won't fetch car anymore
    }
  }
}
```

## spring-boot-starter-data-rest

This dep will search all repositories. No need to create service and controller.

At application.yml set basePath:

```yml
#  dep: spring-boot-starter-data-rest
data:
  rest:
    base-path: /api/v1
```

At Repository, add below: `@RepositoryRestResource` and `@Param`

```java

@RepositoryRestResource // spring-boot-starter-data-rest
public interface CarRepository extends JpaRepository<Car, Long> {
    // spring-boot-starter-data-rest needs @Param then, we can search by
    // http://localhost:8081/api/v1/cars/search/findByBrand?brand=Toyota
    List<Car> findByBrand(@Param("brand") String brand);
}
```

## Spring Security

It enables the following features:

- An AuthenticationManager bean with an in-memory single user. The
  username is user, and the password is printed to the console output.
- Ignored paths for common static resource locations, such as `/css` and `/images`.
  HyperText Transfer Protocol (HTTP) basic security for all other endpoints.
- Security events published to Spring's ApplicationEventPublisher interface.
- Common low-level features are on by default (HTTP Strict Transport Security
  (HSTS), cross-site scripting (XSS), cross-site request forgery (CSRF), and so forth).
- Default autogenerated login page.

Let's add 2 packages: implementation `spring-boot-starter-security` and `spring-security-test`.

### Basic Authentication

When you start your application, you can see from the console that Spring Security has created an in-memory user with a
username as `user`, password in console.

Now, if you make a GET request to root endpoint http://localhost:8080/api, you will see that it is
now secured, which redirects you to the Spring Security **default login page**.

> Using generated security password: b1efefe8-f8f3-4324-a96f-ea88315ab818

Now let's implement the real authentication.

1. A service to load user by username: it will find user exists or not from db.

    ```java
    import org.springframework.security.core.userdetails.UserDetails;
    import org.springframework.security.core.userdetails.UserDetailsService;
    
    @Service
    public class UserDetailsServiceImpl implements UserDetailsService {
        @Autowired
        private UserRepository userRepository;
    
        @Override
    //    Basic authentication, after get the user, compare password.
        public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
            Optional<User> user = userRepository.findByUsername(username);
    
            org.springframework.security.core.userdetails.User.UserBuilder builder;
    
            if (user.isPresent()) {
                User currentUserFromDb = user.get();
    
                builder = org.springframework.security.core.userdetails.User.withUsername(username);
                builder.password(currentUserFromDb.getPassword());
                builder.roles(currentUserFromDb.getRole());
            } else {
                throw new UsernameNotFoundException("User not found.");
            }
    
            return builder.build();
        }
    }
    ```

2. After user types username, password from the default Spring login page. It will use below algo the hash the password,
   and compare with the above user from db.

    ```java
    package com.guanghui.springbootreact.config;
    
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.context.annotation.Configuration;
    import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
    import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
    import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
    import org.springframework.security.core.userdetails.UserDetailsService;
    import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
    
    @Configuration
    @EnableWebSecurity
    public class SecurityConfig extends WebSecurityConfigurerAdapter {
        @Autowired
        private UserDetailsService userDetailsService;
    
        @Autowired
        //  Hash user typed raw password by algorithm, and then compare the result with db password.
        public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception {
            auth.userDetailsService(userDetailsService).passwordEncoder(new BCryptPasswordEncoder());
        }
    }
    ```

Now if we input valid username and password, we should be authenticated and see the `/api`

> Don't forget to exclude `/api/users` from Spring Rest. Spring Data REST generates a RESTful web service from all
> public repositories by default. We can use the exported lag of the `@RepositoryRestResource` annotation and set it
> to `false`, and then the following repository is not exposed as a REST resource.

```java
// UserRepository.java
@Repository
@RepositoryRestResource(exported = false)
public interface UserRepository extends JpaRepository<User, Long> {
    Optional<User> findByUsername(String username);
}
```

### JWT Authentication

3 parts, separated by dots: xxxxx.yyyyy.zzzzz.

- The first part (xxxxx) is the header that defines the type of the token and the
  hashing algorithm.
- The second part (yyyyy) is the payload that, typically, in the case of authentication,
  contains user information.
- The third part (zzzzz) is the signature that is used to verify that the token hasn't
  been changed along the way.

Add packages:

```
implementation'io.jsonwebtoken:jjwt-api:0.11.2'
implementation'io.jsonwebtoken:jjwt-impl:0.11.2'
implementation'io.jsonwebtoken:jjwt-jackson:0.11.2'
```

SecurityConfig.java:

1. add getAuthenticationManager Bean which will be used in `AuthController`.
2. configures which APIs should be authenticated.

```java

@Configuration
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {
    @Autowired
    private UserDetailsServiceImpl userDetailsService;

    @Autowired
    //  Hash user typed raw password by algorithm, and then compare the result with db password.
    public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception {
        auth.userDetailsService(userDetailsService).passwordEncoder(new BCryptPasswordEncoder());
    }

    @Bean
    // Will be injected, @AutoWired in AuthController
    public AuthenticationManager getAuthenticationManager() throws Exception {
        return authenticationManager();
    }

    @Override
    /*
     * 1. defines which paths are secured and which are not secured.
     * e.g. /api/v1/login is allowed without authentication and all other endpoints require.
     * 2. since use jwt, never create a session
     * 3. disable csrf
     * 4. cors
     * 5. auth exception handler
     * 6. auth filter
     */
    protected void configure(HttpSecurity http) throws Exception {
        http.csrf().disable().sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)
                .and()
                .authorizeHttpRequests()
                .antMatchers(HttpMethod.POST, "/api/v1/login")
                .permitAll()
                .anyRequest().authenticated();
    }
}
```

JwtService.java: generate token by username, validate token for further requests.

```java

@Service
public class JwtService {
    static final Integer EXPIRATION_TIME = 86400000; // 1 DAY in ms

    static final String PREFIX = "Bearer";

    // generate secret key. We should read it from Application configuration
    static final Key key = Keys.secretKeyFor(SignatureAlgorithm.HS256);

    /**
     * generate signed JWT token based on username
     *
     * @param username given username
     * @return token
     */
    public String generateToken(String username) {

        return Jwts.builder().setSubject(username)
                .setExpiration(new Date(System.currentTimeMillis() + EXPIRATION_TIME))
                .signWith(key)
                .compact();
    }

    /**
     * verify a token and get username from request Authorization header
     *
     * @param request HttpRequest
     * @return username
     */
    public String validateTokenAndReturnUser(HttpServletRequest request) {
        String token = request.getHeader(HttpHeaders.AUTHORIZATION);

        if (token != null) {
            String user = Jwts.parserBuilder()
                    .setSigningKey(key).build()
                    // NOT.parseClaimsJwt()!!!
                    .parseClaimsJws(token.replace(PREFIX, ""))
                    .getBody()
                    .getSubject();

            return user;
        }

        return null;
    }
}
```

AuthController.java: login success will respond token in Authorization header.

```java

@RestController
public class AuthController {
    @Autowired
    private AuthenticationManager authenticationManager;  // config it at SecurityConfig

    @Autowired
    private JwtService jwtService;

    @PostMapping("/api/v1/login")
    public ResponseEntity<?> getToken(@RequestBody AccountCredentials credentials) {

        UsernamePasswordAuthenticationToken creds = new UsernamePasswordAuthenticationToken(credentials.getUsername(), credentials.getPassword());

        Authentication auth = authenticationManager.authenticate(creds);

        // generate token
        String jwt = jwtService.generateToken(auth.getName());

        // build response with generated token
        return ResponseEntity.ok().header(HttpHeaders.AUTHORIZATION, "Bearer " + jwt)
                .header(HttpHeaders.ACCESS_CONTROL_EXPOSE_HEADERS, "Authorization")
                .build();
    }
}
```

Let's verify from postman: http://localhost:8081/api/v1/login with `{"username": "guanghuiw", "password": "123123"}`.

---

Since we have logged in, now we move on to handle authentication in the incoming requests which should send
Authorization header, where the token should be verified. In the authentication process, we are using filters that allow
us to perform some operations before a request goes to the controller or before a response is sent to a client.

1. Use a filter to authenticate all other incoming requests.

    ```java 
    @Component
    public class AuthenticationFilter extends OncePerRequestFilter {
        @Autowired
        private JwtService jwtService;
    
        @Override
        /*
         * if jwt is validated, set authentication and pass thru to controllers, etc
         */
        protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {
            // A signed JWT is known as a JWS (JSON Web Signature)
            String jwt = request.getHeader(HttpHeaders.AUTHORIZATION);
    
            if (jwt != null) {
                // verify token and get username
                String username = jwtService.validateTokenAndReturnUser(request);
    
                // authenticate
                Authentication authentication = new UsernamePasswordAuthenticationToken(username, null, Collections.emptyList());
    
                SecurityContextHolder.getContext().setAuthentication(authentication);
            }
    
            filterChain.doFilter(request, response);
        }
    }
    ```

2. Next, we have to add our filter class to the Spring Security configuration. Open the
   SecurityConfig class and inject the AuthenticationFilter class that
   we just implemented, as follows:

    ```java
    @Autowired
    private AuthenticationFilter authenticationFilter;
    ```

3. modify the configure method in the SecurityConfig class and add the
   following lines of code:

    ```diff
    protected void configure(HttpSecurity http) throws Exception {
        http.csrf().disable().sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)
                .and()
                .authorizeHttpRequests()
                .antMatchers(HttpMethod.POST, "/api/v1/login")
                .permitAll()
                .anyRequest().authenticated()
    +            .and()
    +            .addFilterBefore(authenticationFilter, UsernamePasswordAuthenticationFilter.class);
    }
    ```

   At this moment, `/api/v1/login` with correct credentials should respond the Authorization token.

4. If login with wrong password, 403 forbidden status returns without further clarification. Implement
   AuthenticationEntryPoint. It will respond 401.

    ```java
    /**
     * 401 unauthorized response
     */
    @Component
    public class AuthEntryPoint implements AuthenticationEntryPoint {
        @Override
        public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException {
            response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
            response.setContentType(MediaType.APPLICATION_JSON_VALUE);
            
            PrintWriter writer = response.getWriter();
            writer.println("Error: " + authException.getMessage());
        }
    }
    ```

5. Config Spring security for exception handling using the above handler:

    ```java
    @Autowired
    private AuthEntryPoint exceptionHandler;
    ```

   Then modify configure method:

    ```diff
    protected void configure(HttpSecurity http) throws Exception {
        http.csrf().disable().cors().and()
                .sessionManagement()
                .sessionCreationPolicy(SessionCreationPolicy.STATELESS).and()
                .authorizeRequests()
                .antMatchers(HttpMethod.POST, "/api/v1/login").permitAll()
                .anyRequest().authenticated().and()
    +            .exceptionHandling()
    +            .authenticationEntryPoint(exceptionHandler).and()
                .addFilterBefore(authenticationFilter, UsernamePasswordAuthenticationFilter.class);
    }
    ```

---

Add CORS to SecurityConfig.java:

```java
@Bean
CorsConfigurationSource corsConfigurationSource(){
        UrlBasedCorsConfigurationSource source=new UrlBasedCorsConfigurationSource();
        CorsConfiguration config=new CorsConfiguration();
        config.setAllowedOrigins(Arrays.asList("*","http://localhost:3000"));
        config.setAllowedMethods(Arrays.asList("*"));
        config.setAllowedHeaders(Arrays.asList("*"));
        config.setAllowCredentials(false);
        config.applyPermitDefaultValues();

        source.registerCorsConfiguration("/**",config);
        return source;
        }
```

```diff
protected void configure(HttpSecurity http) throws Exception {
    http.csrf().disable()
+            .cors().and()
            .sessionManagement()
            .sessionCreationPolicy(SessionCreationPolicy.STATELESS).and()
            .authorizeRequests()
            .antMatchers(HttpMethod.POST, "/api/v1/login").permitAll()
            .anyRequest().authenticated().and()
            .exceptionHandling()
            .authenticationEntryPoint(exceptionHandler).and()
            .addFilterBefore(authenticationFilter, UsernamePasswordAuthenticationFilter.class);
}
```

## Testing

By default, Spring Boot uses an in-memory database for testing. We are now using postgres, so we can change H2 scope for
testing only, but H2 can also be used for testing if we add the following dependency to the pom.xml ile. he scope deines
that the H2 database will only be used for running tests; otherwise, the application will use the MariaDB database:

Way 1:

```groovy
//    https://blog.csdn.net/zh452647457/article/details/108772045
testRuntimeOnly 'com.h2database:h2'
```

Way 2:

If you also want to use the default database for testing, you can use the `@AutoConfigureTestDatabase` annotation.

```diff

@SpringBootTest
+ //this should use the default in-memory db
+ @AutoConfigureTestDatabase
class SpringBootReactApplicationTests {
    
}
```

See tests in OwnerRepositoryTest.java.