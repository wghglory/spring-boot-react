# Spring boot fundamental

`@SpringBootApplication` annotation is a combination of
multiple annotations, such as the following:

- `@EnableAutoConfiguration`: enables automatic configuration based on dependencies. e.g. `spring-boot-starter-web`
  assumes that you're developing a web application and configure it accordingly.
- `@ComponentScan`: scan to find all components
- `@Configure`: defines a class as a source of bean definitions

## Json serialization infinite loop which happens on account of one-to-many relationship between the car and owner tables.

One solution: `@JsonIgnoreProperties({"hibernateLazyInitializer", "handler"})` + `@JsonIgnore`

GET `/api/v1/cars`

```diff
// ignore fields generated by Hibernate:
+ @JsonIgnoreProperties({"hibernateLazyInitializer", "handler"})
public class Owner {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long ownerId;

    // ...

    // 1 owner can have many cars
    @OneToMany(cascade = CascadeType.ALL, mappedBy = "owner")
    // mappedBy value is the field in Car class (private Owner `owner`)
+    @JsonIgnore
    private List<Car> cars;
}
```

This means when cars get owners, at the owners place, stop fetching cars. So the result is like

```json5
{
  "car": {
    "carId": 1,
    "owner": {
      "ownerId": 2
      // won't fetch car anymore
    }
  }
}
```

## spring-boot-starter-data-rest

This dep will search all repositories. No need to create service and controller.

At application.yml set basePath:

```yml
#  dep: spring-boot-starter-data-rest
data:
  rest:
    base-path: /api/v1
```

At Repository, add below: `@RepositoryRestResource` and `@Param`

```java

@RepositoryRestResource // spring-boot-starter-data-rest
public interface CarRepository extends JpaRepository<Car, Long> {
    // spring-boot-starter-data-rest needs @Param then, we can search by
    // http://localhost:8081/api/v1/cars/search/findByBrand?brand=Toyota
    List<Car> findByBrand(@Param("brand") String brand);
}
```

## Spring Security

It enables the following features:

- An AuthenticationManager bean with an in-memory single user. The
  username is user, and the password is printed to the console output.
- Ignored paths for common static resource locations, such as `/css` and `/images`.
  HyperText Transfer Protocol (HTTP) basic security for all other endpoints.
- Security events published to Spring's ApplicationEventPublisher interface.
- Common low-level features are on by default (HTTP Strict Transport Security
  (HSTS), cross-site scripting (XSS), cross-site request forgery (CSRF), and so forth).
- Default autogenerated login page.

Let's add 2 packages: implementation `spring-boot-starter-security` and `spring-security-test`.

### Basic Authentication

When you start your application, you can see from the console that Spring Security has created an in-memory user with a
username as `user`, password in console.

Now, if you make a GET request to root endpoint http://localhost:8080/api, you will see that it is
now secured, which redirects you to the Spring Security **default login page**.

> Using generated security password: b1efefe8-f8f3-4324-a96f-ea88315ab818

Now let's implement the real authentication.

1. A service to load user by username: it will find user exists or not from db.

    ```java
    import org.springframework.security.core.userdetails.UserDetails;
    import org.springframework.security.core.userdetails.UserDetailsService;
    
    @Service
    public class UserDetailsServiceImpl implements UserDetailsService {
        @Autowired
        private UserRepository userRepository;
    
        @Override
    //    Basic authentication, after get the user, compare password.
        public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
            Optional<User> user = userRepository.findByUsername(username);
    
            org.springframework.security.core.userdetails.User.UserBuilder builder;
    
            if (user.isPresent()) {
                User currentUserFromDb = user.get();
    
                builder = org.springframework.security.core.userdetails.User.withUsername(username);
                builder.password(currentUserFromDb.getPassword());
                builder.roles(currentUserFromDb.getRole());
            } else {
                throw new UsernameNotFoundException("User not found.");
            }
    
            return builder.build();
        }
    }
    ```

2. After user types username, password from the default Spring login page. It will use below algo the hash the password,
   and compare with the above user from db.

    ```java
    package com.guanghui.springbootreact.config;
    
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.context.annotation.Configuration;
    import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
    import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
    import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
    import org.springframework.security.core.userdetails.UserDetailsService;
    import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
    
    @Configuration
    @EnableWebSecurity
    public class SecurityConfig extends WebSecurityConfigurerAdapter {
        @Autowired
        private UserDetailsService userDetailsService;
    
        @Autowired
        //  Hash user typed raw password by algorithm, and then compare the result with db password.
        public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception {
            auth.userDetailsService(userDetailsService).passwordEncoder(new BCryptPasswordEncoder());
        }
    }
    ```

Now if we input valid username and password, we should be authenticated and see the `/api`

> Don't forget to exclude `/api/users` from Spring Rest. Spring Data REST generates a RESTful web service from all
> public repositories by default. We can use the exported lag of the `@RepositoryRestResource` annotation and set it
> to `false`, and then the following repository is not exposed as a REST resource.

```java
// UserRepository.java
@Repository
@RepositoryRestResource(exported = false)
public interface UserRepository extends JpaRepository<User, Long> {
    Optional<User> findByUsername(String username);
}
```

### JWT Authentication

3 parts, separated by dots: xxxxx.yyyyy.zzzzz.

- The first part (xxxxx) is the header that defines the type of the token and the
  hashing algorithm.
- The second part (yyyyy) is the payload that, typically, in the case of authentication,
  contains user information.
- The third part (zzzzz) is the signature that is used to verify that the token hasn't
  been changed along the way.

Add packages:

```
implementation'io.jsonwebtoken:jjwt-api:0.11.2'
implementation'io.jsonwebtoken:jjwt-impl:0.11.2'
implementation'io.jsonwebtoken:jjwt-jackson:0.11.2'
```

SecurityConfig.java:

1. add getAuthenticationManager Bean which will be used in `AuthController`.
2. configures which APIs should be authenticated.

```java

@Configuration
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {
    @Autowired
    private UserDetailsService userDetailsService;

    @Autowired
    //  Hash user typed raw password by algorithm, and then compare the result with db password.
    public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception {
        auth.userDetailsService(userDetailsService).passwordEncoder(new BCryptPasswordEncoder());
    }

    @Bean
    public AuthenticationManager getAuthenticationManager() throws Exception {
        return authenticationManager();
    }

    @Override
    /*
     * 1. defines which paths are secured and which are not secured.
     * e.g. /api/v1/login is allowed without authentication and all other endpoints require.
     * 2. since use jwt, never create a session
     * 3. disable csrf
     */
    protected void configure(HttpSecurity http) throws Exception {
        http.csrf().disable().sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)
                .and()
                .authorizeHttpRequests()
                .antMatchers(HttpMethod.POST, "/api/v1/login")
                .permitAll()
                .anyRequest().authenticated();
    }
}
```

JwtServiceImpl.java: generate token by username, validate token for further requests.

```java
package com.guanghui.springbootreact.service;

import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import io.jsonwebtoken.security.Keys;
import org.springframework.http.HttpHeaders;
import org.springframework.stereotype.Service;

import javax.servlet.http.HttpServletRequest;
import java.security.Key;
import java.util.Date;

@Service
public class JwtServiceImpl {
    static final Integer EXPIRATION_TIME = 86400000; // 1 DAY in ms

    static final String PREFIX = "Bearer";

    // generate secret key. We should read it from Application configuration
    static final Key key = Keys.secretKeyFor(SignatureAlgorithm.HS256);

    /**
     * generate signed JWT token based on username
     *
     * @param username
     * @return token
     */
    public String generateToken(String username) {

        return Jwts.builder().setSubject(username)
                .setExpiration(new Date(System.currentTimeMillis() + EXPIRATION_TIME))
                .signWith(key)
                .compact();
    }

    /**
     * verify a token and get username from request Authorization header
     *
     * @param request
     * @return username
     */
    public String getAuthUser(HttpServletRequest request) {
        String token = request.getHeader(HttpHeaders.AUTHORIZATION);

        if (token != null) {
            String user = Jwts.parserBuilder()
                    .setSigningKey(key).build()
                    .parseClaimsJwt(token.replace(PREFIX, ""))
                    .getBody()
                    .getSubject();

            return user;
        }

        return null;
    }
}
```

AuthController.java: login success will respond token in Authorization header.

```java
package com.guanghui.springbootreact.controller;

import com.guanghui.springbootreact.model.AccountCredentials;
import com.guanghui.springbootreact.service.JwtServiceImpl;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpHeaders;
import org.springframework.http.ResponseEntity;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class AuthController {
    @Autowired
    AuthenticationManager authenticationManager;  // config it at SecurityConfig

    @Autowired
    private JwtServiceImpl jwtService;

    @PostMapping("/api/v1/login")
    public ResponseEntity<?> getToken(@RequestBody AccountCredentials credentials) {

        UsernamePasswordAuthenticationToken creds = new UsernamePasswordAuthenticationToken(credentials.getUsername(), credentials.getPassword());

        Authentication auth = authenticationManager.authenticate(creds);

        // generate token
        String jwt = jwtService.generateToken(auth.getName());

        // build response with generated token
        return ResponseEntity.ok().header(HttpHeaders.AUTHORIZATION, "Bearer " + jwt)
                .header(HttpHeaders.ACCESS_CONTROL_EXPOSE_HEADERS, "Authorization")
                .build();
    }
}
```

Let's verify from postman: http://localhost:8081/api/v1/login with `{"username": "guanghuiw", "password": "123123"}`.

---

Since we have logged in, now we move on to handle authentication in the incoming requests which should send
Authorization header, where the token should be verified. In the authentication process, we are using filters that allow
us to perform some operations before a request goes to the controller or before a response is sent to a client. 

